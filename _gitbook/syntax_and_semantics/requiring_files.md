# requireでのファイル参照

小さなプログラムやベンチマーク用途なら一つのファイルに書くのはもちろんＯＫですが、大きなプログラムは、いくつかファイルに分けるとメンテナンスが楽であり、また理解もし易いです。

コンパイラ処理を他のファイルで行いたい時は `require "..."`を使用してください。引数は一つで、文字列リテラルであれば、いろいろ記述できます。

一度require処理されると、コンパイラはその絶対パスを記憶し、その後は同じ名前のファイルは無視されます。

## require "filename"

この記述では、"filename" を以下のようにrequire参照します。

デフォルトで、必要なパスは、コンパイラとセットで提供されるstandard libraryデイレクトリと、現在のワーキングデイレクトリから相対的に指定される"libs"を参照します（つまり、unix shellで言う`pwd`で与えられるデイレクトリです）。参照されるデイレクトリは、これらのみです。

参照は、以下のように処理されます：

*もし"filename.cr"というファイル名がrequire pathに見つかったら、それは参照する。
*もしデイレクトリ名で "filename"が見つかり、そこに"filename.cr"が含まれていたら、それは参照する。
*それ以外はコンパイルエラーになる。

2番目のルールは、プロジェクトでよく使われるデイレクトリ構造でもあり、便利です：

```
- project
  - libs
    - foo
      foo.cr
    - bar
      bar.cr
  - src
    - project.cr
  - spec
    - project_spec.cr
```

## require "./filename"

この場合、requireを読み込んだファイルの場所から相対的に"filename"を参照します。

参照は、以下のように処理されます：

* もし"filename.cr"というファイル名が現在のファイルの場所から相対的指定場所に見つかったら、それは参照する。
* もしデイレクトリ名で "filename"が見つかり、そこに"filename.cr"が含まれていたら、それは参照する。
* それ以外はコンパイルエラーになる。

この相対パス参照はプロジェクトで使われるそのデイレクトリの中にある他のファイルを使う時によく使われますし、またspecs:からコードを参照する場合にも使われます：

```ruby
# in spec/project_spec.cr
require "../src/project"
```

## その他の形式

上記どちらの場合でも、ネストされた名前が使用でき、指定するとネストされたデイレクトリを参照することになります：

* `require "foo/bar/baz"` はrequire pathにある"foo/bar/baz.cr" あるいは "foo/bar/baz/baz.cr"を参照する 。
* `require "./foo/bar/baz"`は現在のファイル位置から相対的に見て  "foo/bar/baz.cr" あるいは "foo/bar/baz/baz.cr" を参照する。

"../"を利用することによって現在のファイル位置から親のデイレクトリをアクセスできますし、`require "../../foo/bar"`も同様です。

これらのすべての場合において、 `*`と `**`が利用できます：

* `require "foo/*"` は"foo"デイレクトリ内の全ての ".cr" ファイルをrequire参照し、それ以下のデイレクトリは参照しない。
* `require "foo/**"`は"foo"デイレクトリ配下の全ての ".cr"ファイルをrequire参照し、それ以下のデイレクトリも再帰的に参照する。

